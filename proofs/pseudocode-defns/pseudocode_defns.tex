\documentclass[11pt,a4paper]{article}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{enumerate} 
\usepackage{physics}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\hypersetup{colorlinks,
    linkcolor=blue,
    citecolor=blue,      
    urlcolor=blue,
    %linktoc=none
}

\oddsidemargin0.1cm 
\evensidemargin0.8cm
\textheight22.7cm 
\textwidth15cm \topmargin-0.5cm

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}
\newtheorem*{theorem-non}{Theorem}

\theoremstyle{definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{observation}{Observation}
\newtheorem{note}[theorem]{Note}
\newtheorem{hope}{Hope}
\newtheorem{warning}{Warning}
\newtheorem{problem}{Problem}
\newtheorem{fear}{Fear}
\newtheorem{question}{Question}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\A}{\mathbb{A}}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\MultiSets}{\mathrm{MultiSets}}
\newcommand{\MultiSet}{\mathrm{MultiSets}}
\newcommand{\len}{\mathrm{len}}
\newcommand{\din}{d_{in}}
\newcommand{\dout}{d_{out}}
\newcommand{\Relation}{\mathrm{Relation}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\Y}{\mathcal{Y}}
\newcommand{\True}{\texttt{True}}
\newcommand{\False}{\texttt{False}}
\newcommand{\clamp}{\texttt{clamp}}
\newcommand{\horizline}{\noindent\rule{\textwidth}{1pt}}


\newcommand{\silvia}[1]{{ {\color{blue}{(silvia)~#1}}}}
\newcommand{\grace}[1]{{ {\color{purple}{(grace)~#1}}}}
\newcommand{\connor}[1]{{ {\color{teal}{(connor)~#1}}}}
\newcommand{\sfi}{}%{\text{\textcolor{olive}{(Salil's feedback incorporated.)}}}
\newcommand{\todosfi}{\todo{Add Salil's feedback.}}

\newcommand{\metricDefn}[1]{The definition of \emph{#1} in the proof definitions document (see section \ref{sec:versioned-docs}) tells how the distance between data is calculated.}

\newcommand{\inRust}[2]{See \url{#2}.}
\newcommand{\inOpenDPRust}[2]{In OpenDP (Rust), this is called \texttt{#1}. See \url{#2}.}
\newcommand{\inPython}[2]{In Python, this is called \texttt{#1}. See \url{#2}.}
\newcommand{\questionc}[1]{\textcolor{red}{\textbf{Question:} #1}}
\newcommand{\questionr}[1]{\textcolor{blue}{\textbf{Question for reviewers:}}\textcolor{red}{~#1}}
\newcommand{\T}{\texttt{T}}
\newcommand{\data}{\texttt{data}}
\newcommand{\todo}{{\textcolor{red}{TODO: }}}
\newcommand{\todonei}{{\textcolor{red}{TODO (future -- not enough info yet): }}}
\newcommand{\iffText}{\text{if and only if}}
\newcommand{\domainType}[1]{This domain has type \texttt{#1}.}


\title{List of definitions used in the pseudocode\footnote{Based off the version from Summer 2021 interns, S\'ilvia Casacuberta, Grace Tian, and Connor Wagaman}}
\author{Vicki Xu, Hanwen Zhang, Zachary Ratliff}
\date{Summer 2022 \\ Version as of \today~(UTC)}

\begin{document}

\maketitle

We use the following guideline: if a term appears in the \texttt{\textbackslash\texttt{texttt\{...\}}} \LaTeX font, then this term is defined in the pseudocode definitions document. Otherwise, it appears in the proof definitions document. 

We provide the terms in alphabetical order within each section. ``TODOs'' should be included at the end of the corresponding section. On the other hand, ``TODOs'' which better specify an already-defined term should be included immediately following the definition of that term. Examples should never be part of the definition, but we encourage their use right after the definition of a term.

We also recommend linking to the Rust Standard Library when the term is defined there.

\tableofcontents

\subsection{List of terms that have not yet been added}
\begin{itemize}
    \item The compatibility pairing and subdomains. Compatibility inheritance for subdomains and proof for subdomain traits. But this is awaiting the specific final implementation.
    \item Clarify why we specify vectors for \texttt{SizedDomain}
    \item Add definition of a valid measurement
    \item Double-check newly added definitions, and trait vs function (e.g., \texttt{SaturatingAdd} and \texttt{saturating\_add})
    \item Incorporate corrections from GitHub
    \item Add type trait \texttt{Laplace Domain}, and the other ones from base Laplace: \texttt{D::Atom}, \texttt{SampleLaplace}, \texttt{Float}, and \texttt{InfCast(D::Atom)}.
    \item Add function \texttt{is\_sign\_negative()} from Laplace
    \item Add function \texttt{.recip()} from Laplace
    \item Add function \texttt{sample\_laplace} (idealized, for now)
    \item Add \texttt{IntDistance}, although Mike said to keep using \texttt{u32} in the pseudocode type signing for now.
    \item Definition of the Rust iterator
    \item Do we need \texttt{fold}? Maybe always use loops
\end{itemize}

\subsection{Versions of definitions documents}
\label{sec:versioned-docs}

When looking for definitions for terms that appear in this document, the following versions of the definitions documents should be used.

\begin{itemize}
    \item \textbf{Proof definitions document:} This file uses the version of the proof definitions document available as of September 23, 2021, which can be found at \href{https://github.com/opendp/whitepapers/blob/proof-defns/proof-defns/proof_defns.pdf}{this link} (archived \href{https://github.com/opendp/whitepapers/blob/f43bf7056a5fd3b6f7b4bb77d451eafa042fe8f7/proof-defns/proof_defns.pdf}{here}). 
\end{itemize}

\section{Types}
% any types should be listed here

\begin{note}[A note on \texttt{()} vs. \texttt{[]}] Parentheses, \texttt{()}, are used to create an instance of a domain. Square brackets, \texttt{[]}, are used to describe the type of a domain.

For example, \texttt{AllDomain(i8)} is the domain of all values of type \texttt{i8}. However, the type of \texttt{AllDomain(i8)} -- the domain itself, not the elements of the domain -- is \texttt{AllDomain[i8]}; note the square brackets. This typing style is inspired by the notation used in Python; see \url{https://docs.python.org/3/library/typing.html}.
\end{note}

\begin{definition}[\texttt{bool}]
    The type \texttt{bool} represents a value which can only be either \texttt{True} or \texttt{False}. If a \texttt{bool} is \texttt{cast}ed to an integer, \texttt{True} will be \texttt{1} and \texttt{False} will be \texttt{0}.
\end{definition}

\begin{definition}[\texttt{::Carrier}]
\texttt{SomeDomain::Carrier} is the type of a member in \texttt{SomeDomain}, where \texttt{SomeDomain} is a domain. See section \ref{sec:domains} for more information on domains. 
\end{definition}

For example, \texttt{AllDomain(T)::Carrier} is $\T$.

\begin{definition}[\texttt{f32}]$\sfi$
    \texttt{f32} is the Rust 32-bit floating point type. 
    
    \inRust{f32}{https://doc.rust-lang.org/std/primitive.f32.html}
\end{definition}

\begin{definition}[\texttt{f64}]$\sfi$
    \texttt{f64} is the Rust 64-bit floating point type. 
    
    \inRust{f64}{https://doc.rust-lang.org/std/primitive.f64.html} 
\end{definition}

\todonei{Add / pointers to  ``binary64‚Äù type defined in IEEE 754-2008.}
\begin{definition}[\texttt{::Imputed}]
\texttt{SomeDomain::Imputed} is the type of \texttt{SomeDomain} after imputation, where \texttt{SomeDomain} is a domain. 
\end{definition}
Note however, that \texttt{SomeDomain::Imputed} may contain a null value. See the proof section of \href{https://www.overleaf.com/project/60fed2512ffa2d5983b1d0eb}{proof section of \texttt{impute\_constant}}. 
\begin{definition}[\texttt{IntDistance}]
\texttt{IntDistance} is equivalent to \texttt{u32}.
\end{definition}
\begin{definition}[\texttt{isize}]
    \texttt{isize} is defined differently on 32-bit and 64-bit machines. This is because the size of this primitive is equal to the number of bytes it takes to reference any location in memory.
    \begin{itemize}
        \item \textbf{32-bit machines:} for \texttt{v} a value of type \texttt{usize}, $\texttt{v}\in \{-2^{31},\ldots,-1,0,1,\ldots,2^{32} - 1\}$
        \item \textbf{64-bit machines:} for \texttt{v} is a value of type \texttt{usize}, $\texttt{v}\in \{-2^{63},\ldots,-1,0,1,\ldots,2^{63} - 1\}$
    \end{itemize}
    
    \inRust{isize}{https://doc.rust-lang.org/std/primitive.isize.html}
\end{definition}
\begin{definition}[\texttt{Option}]
    The type \texttt{Option[T]} is the type for all values of type \texttt{T}, as well as the type for the values \texttt{None} and \texttt{Some}, where \texttt{Some(val:T)} is equal to \texttt{val}.
    
    \inRust{Enum std::option::Option}{https://doc.rust-lang.org/std/option/enum.Option.html}
\end{definition}
\begin{definition}[\texttt{u32}]$\sfi$
    \texttt{u32} is the Rust 32-bit unsigned integer type. If $v$ is a value of type \texttt{u32}, then we know that $v\in \{0,1,2,\ldots, 2^{32}-1\}$. 
    
    \inRust{u32}{https://doc.rust-lang.org/std/primitive.u32.html}
\end{definition}
\begin{definition}[\texttt{usize}]
    \texttt{usize} is defined differently on 32-bit and 64-bit machines. This is because the size of this primitive is equal to the number of bytes it takes to reference any location in memory.
    \begin{itemize}
        \item \textbf{32-bit machines:} if \texttt{v} is a value of type \texttt{usize}, then $\texttt{v}\in \{0,1,2,\ldots,2^{32} - 1\}$
        \item \textbf{64-bit machines:} if \texttt{v} is a value of type \texttt{usize}, then $\texttt{v}\in \{0,1,2,\ldots,2^{64} - 1\}$
    \end{itemize}
    
    \inRust{usize}{https://doc.rust-lang.org/std/primitive.usize.html}
\end{definition}
\begin{definition}[\texttt{Vec[T]}]$\sfi$
    The Rust type \texttt{Vec[T]} consists of ordered lists of type \texttt{T}. For example, if \texttt{T = bool}, then values of type \texttt{Vec[T]} include $\texttt{[], [0], [1], [0, 0],} \ldots$. A vector can contain no more than \texttt{get\_max\_value(usize)} elements. 
    
    \inRust{Vec<T>}{https://doc.rust-lang.org/std/vec/struct.Vec.html}
\end{definition}
\horizline
\subsection{Notes, todos, questions}
%\silvia{Discuss: bounded vs lower bound and upper bound}
%\todonei{Include info on MPFR, and possibly relate it to our existing definitions of floats.}
\questionr{Should we have a general definition for ``floats'' (and ``integers''?), or is it sufficiently understood what a float is?}


\section{Domains}
\label{sec:domains}
$\sfi$ A \emph{data domain} is a representation of the set of values on which the function associated with a transformation or measurement can operate.  Each metric (see section \ref{sec:metrics}) is associated with certain data domains. Types used for implementing domains in OpenDP have trait \texttt{Domain} (defined in definition \ref{defn:traits-domain}).
\begin{definition}[\texttt{AllDomain}]$\sfi$
\texttt{AllDomain(T)} is the domain of all values of type $\T$. \domainType{AllDomain[T]}
\end{definition}
For example, \texttt{AllDomain(u32)} is the domain of all values of type \texttt{u32}.
\begin{definition}[\texttt{IntervalDomain}] \sfi For any type \texttt{T} with trait \texttt{TotalOrd} (see definition \ref{defn:totalord}),\footnote{As of June 28, the OpenDP library requires the weaker condition of partial ordering (implements \texttt{PartialOrd}) instead.} \texttt{IntervalDomain(L:T, U:T)} is the domain of all values \texttt{v} of type \texttt{T} such that \texttt{L <= v} and \texttt{v <= U}, for a type \texttt{T} that has a total ordering (\texttt{T} has trait \texttt{TotalOrd}) and for values \texttt{L <= U} of type \texttt{T}. \domainType{IntervalDomain[T]}
\end{definition}
An important remark is that the Rust implementation of \texttt{IntervalDomain} checks that \texttt{L <= U}, and returns an error if \texttt{L > U}. Therefore, any transformation or measurement that uses \texttt{IntervalDomain} does not need to re-check this constraint and raise a possible exception for it. 
Note that, because both \texttt{L} and \texttt{U} are of type \texttt{T}, there is no need to explicitly pass \texttt{T}; the type \texttt{T} can be inferred. \texttt{IntervalDomain} is defined on any type that implements the trait \texttt{TotalOrd}. For example, \texttt{IntervalDomain(1:u32, 17:u32)} corresponds to a domain that contains all the \texttt{u32} values \texttt{v} such that \texttt{1 <= v} and \texttt{v <= 17}; it has type \texttt{IntervalDomain[u32]}.
\begin{definition}[\texttt{InherentNullDomain}] 
    \texttt{InherentNullDomain(inner\_domain:D)} is the domain of all values of data domain \texttt{inner\_domain} unioned with a \texttt{null} value. Note that this means that a domain may have only \emph{one} \texttt{null} value; as a result, applying \texttt{InherentNullDomain} to a domain already containing a \texttt{null} value will not affect the domain. \domainType{InherentNullDomain[D]}
\end{definition}
\begin{definition}[\texttt{SizedDomain}] $\sfi$
    \texttt{SizedDomain(inner\_domain:D, n:usize)} is the domain of all elements from domain \texttt{D} restricted to length \texttt{n}. \domainType{SizedDomain[D]}
\end{definition}
For example, \texttt{SizedDomain(VectorDomain(AllDomain(u32)), n)} is the domain of all vectors of length $\texttt{n}$ with elements of type \texttt{u32}.
\begin{definition}[\texttt{VectorDomain}]
\texttt{VectorDomain(inner\_domain:D)} is the domain of all vectors of elements drawn from domain \texttt{inner\_domain}. 
\domainType{VectorDomain[D]}
\end{definition}
\subsection{Subdomains}
\horizline
\subsection{Notes, todos, questions}
\todonei{As of July 20, OpenDP plans to include subdomains (see the Architecture meeting notes for 20/7). We have to include them and prove that they are indeed subdomains. Then in the metric definition it is enough to list the most general domain, since the domain-metric compatibility in inherited. We will add the necessary information here after Mike and Andy have finished the implementation details.}
Preliminary theorems:
\begin{theorem}[Domain-metric compatibility inheritance.]
    Given a domain \texttt{D}, for any subdomain \texttt{S} $\subseteq$ \texttt{D}, if \texttt{D} is compatible with metric \texttt{M} then \texttt{S} is compatible with metric \texttt{M}.
\end{theorem}
\section{Traits}
% any traits should be defined here
\begin{definition}[\texttt{Abs}]
    A type \texttt{T} has trait \texttt{Abs} if and only if the absolute value of a value of type \texttt{T} can be taken.
\end{definition}
\begin{definition}[\texttt{Bounded}]
    A type $\T$ has trait \texttt{Bounded} $\iffText$ $\T$ has some upper bound and some lower bound (some smallest possible value and some largest possible value).
\end{definition}
\begin{definition}[\texttt{CheckedAdd}]
    A type \texttt{T} has trait \texttt{CheckedAdd} if it performs subtraction \texttt{checked\_add} that returns \texttt{None} if overflowing/underflowing occurs.
\end{definition}
\begin{definition}[\texttt{CheckedMul}]
    A type \texttt{T} has trait \texttt{CheckedMul} if it performs multiplication using \texttt{checked\_mul} that returns \texttt{None} if overflowing/underflowing occurs.
\end{definition}
\begin{definition}[\texttt{CheckedSub}]
    A type \texttt{T} has trait \texttt{CheckedSub} if it performs subtraction \texttt{checked\_sub} that returns \texttt{None} if overflowing/underflowing occurs.
\end{definition}
\begin{definition}[\texttt{DistanceConstant}]
    A type \texttt{TO} has trait \texttt{DistanceConstant(TI)} if:
    \begin{itemize}
        \item \texttt{TO} has trait \texttt{Mul(Output=TO)} (multiplication can be done with type \texttt{TO})
        \item \texttt{TO} has trait \texttt{Div(Output=TO)} (some form of inverse mapping can be done with type \texttt{TO})
        \item \texttt{TO} has trait \texttt{PartialOrd} (\texttt{TO} has a partial ordering)
        \item \texttt{TO} has trait \texttt{InfCast(TI)}
    \end{itemize}
    
    \inOpenDPRust{DistanceConstant}{https://github.com/opendp/opendp/blob/main/rust/opendp/src/traits.rs}
\end{definition}
\begin{definition}[\texttt{Domain}]
\label{defn:traits-domain}
A type \texttt{T} has trait \texttt{Domain} $\iffText$ it can represent a set of values that make up a domain. The \texttt{Domain} implementation prescribes a type for members of the domain, as well as a method to check if any instance of that type is a member of that domain.
\end{definition}
\begin{definition}[\texttt{ExactIntCast}]
    A type \texttt{TO} has trait \texttt{ExactIntCast(TI)} $\iffText$ Every value of type \texttt{TI} can be \texttt{exact\_int\_cast}ed exactly to a value of type \texttt{TO}, as long as the original value of type \texttt{TI} is no smaller than \texttt{get\_min\_consecutive\_int(TO)} and no larger than \texttt{get\_max\_consecutive\_int(TO)}.
    
    A cast error is returned when the value being \texttt{exact\_int\_cast}ed is greater than \texttt{get\_max\_consecutive\_int(TO)} or less than \texttt{get\_min\_consecutive\_int(TO)}.
\end{definition}
\begin{definition}[\texttt{Float}]
    Generic trait for floating point numbers. A type \texttt{T} with trait \texttt{Float} automatically implements trait \texttt{Div<Self, Output = Self>}.
\end{definition}
\begin{definition}[\texttt{ImputableDomain}] 
Any domain for which the \texttt{ImputableDomain} trait is implemented for it, has 
\begin{itemize}
    \item an associated type \texttt{Imputed}. \texttt{VectorDomain::Imputed} is the data type after imputation. 
    \item an imputation function \texttt{impute\_constant} that replaces a null value with a constant or passes a non-null value through. The pseudocode is \\
    \texttt{def impute\_constant(x: DA) -> DA::Imputed: \\ return constant if x.is\_null else x}
    \item  a function \texttt{is\_null} to check if a value is \texttt{null}
    \item a function \texttt{new} to construct an instance of the domain
\end{itemize}
\end{definition}
\begin{definition}[\texttt{InfCast}]
A type \texttt{TO} has trait \texttt{InfCast(TI)} $\iffText$ for every value \texttt{val} of type \texttt{TI}, \texttt{inf\_cast(val:TI,TO)} is defined (note in definition \ref{defn:inf-cast} for \texttt{inf\_cast} that it is acceptable for \texttt{inf\_cast(val:TI,TO)} to return an error).
\emph{Note: the name ``InfCast'' comes from the idea of rounding the result of the cast toward positive \textbf{inf}inity if needed.}
\end{definition}
\begin{definition}[\texttt{InherentNull}]
A type \texttt{T} has trait \texttt{InherentNull} $\iffText$ type \texttt{T} can hold some value \texttt{null}.
As of July 16, 2021, only \texttt{f32} and \texttt{f64} have the trait \texttt{InherentNull}.
\end{definition}
\begin{definition}[\texttt{MaxConsecutiveInt}]
A type $\T$ has trait \texttt{MaxConsecutiveInt} if and only if there is some maximum integer \texttt{i} such that all integers from 0 up to \texttt{i} (inclusive) can be expressed as a value of type $\T$; but such that the next integer that can be expressed by $\T$ is not $\texttt{i}+1$.
\end{definition}
\begin{definition}[\texttt{MinConsecutiveInt}]
A type $\T$ has trait \texttt{MinConsecutiveInt} if and only if there is some minimum integer \texttt{i} such that all integers from 0 up to \texttt{i} (inclusive) can be expressed as a value of type $\T$; but such that the next integer that can be expressed by $\T$ is not $\texttt{i}+1$.
\end{definition}
\begin{definition}[\texttt{Metric}]
A type \texttt{T} has trait \texttt{Metric} $\iffText$ it can represent a metric for quantifying distances between values in a set. The \texttt{Metric} implementation additionally prescribes the type to use for representing distances.
\end{definition}
\begin{definition}[\texttt{One}]
    A type $\T$ has trait \texttt{One} $\iffText$ $\T$ has some multiplicative identity element. A type \texttt{T} with trait \texttt{One} automatically implements trait \texttt{Mul(Output = T)}.
\end{definition}
\begin{definition}[\texttt{OptionNull}]
A type \texttt{Option[T]} has trait \texttt{OptionNull} $\iffText$ \texttt{null} can be represented as a value of type \texttt{Option[T].}
\end{definition}
\begin{definition}[\texttt{PartialEq}]
    A type $\T$ has trait \texttt{PartialEq} $\iffText$ values of type $\T$ have a partial equivalence relation defined on them. A relation $R$ is a partial equivalence relation $\iffText$ for all \texttt{a,b,c} of type $\T$, we have:
    \begin{itemize}
        \item \textbf{symmetry:} if \texttt{a}$R$\texttt{b}, then \texttt{b}$R$\texttt{a}.
        \item \textbf{transitivity:} if \texttt{a}$R$\texttt{b} and \texttt{b}$R$\texttt{c}, then \texttt{a}$R$\texttt{c}
    \end{itemize}
    
    \inRust{Trait std::cmp::PartialEq}{https://doc.rust-lang.org/std/cmp/trait.PartialEq.html}
\end{definition}
\begin{definition}[\texttt{PartialOrd}]\label{def:partial}
A type \texttt{T} has trait \texttt{PartialOrd} if for all elements \texttt{a, b, c} of type \texttt{T}, the following properties are satisfied:
%A partial ordering over a data domain is a binary relation $\leq$ such that for all $a, b, c$ in this data domain, the following properties are satisfied.
    \begin{enumerate}
        \item \textbf{asymmetry}: if \texttt{a < b} then \texttt{not(a > b)}; likewise, if \texttt{a > b} then \texttt{not(a < b)}
        
        \questionr{Is the meaning of ``\texttt{not}'' above clear? In math, the first statement above would be written as ``if $a < b$ then $a \ngtr b$''.}
        
        \item \textbf{transitivity}: if \texttt{a < b} and \texttt{b < c}, then \texttt{a < c}; the same holds for \texttt{==} and \texttt{>}.
    \end{enumerate}
%The partial ordering relation is denoted by \texttt{PartialOrd}.
\inRust{Trait std::cmp::PartialOrd}{https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html}
\end{definition}
\begin{definition}[\texttt{SaturatingAdd}]
    A type \texttt{T} has trait \texttt{SaturatingAdd} if the function \texttt{saturating\_add} (defined in definition \ref{defn:fn-saturating-add}) can be called on values of type \texttt{T}.
\end{definition}
\begin{definition}[\texttt{TotalOrd}]
\label{defn:trait-totalord}
    \label{defn:totalord}
    A type \texttt{T} has trait \texttt{TotalOrd} if and only if \texttt{T} has trait \texttt{PartialOrd} and moreover all elements are comparable; that is, for all elements $a, b$ of type \texttt{T}, either $a \leq b$ or $b \leq a$.
    
    %A total ordering over a data domain is a partial ordering  in which any two elements are comparable. That is, along with the three properties given in Definition~\ref{def:partial}, one more property must be satisfied: $a \leq b$ or $b \leq a$.
    
    %The total ordering relation is denoted by \texttt{TotalOrd}.
\end{definition}
\begin{definition}[\texttt{Zero}]
A type $\T$ has trait \texttt{Zero} $\iffText$ $\T$ has some additive identity element. A type \texttt{T} with trait \texttt{Zero} automatically implements trait \texttt{Add(Output = T)}.
\end{definition}

\begin{definition}[\texttt{InfLn}]
A type $\T$ has trait \texttt{InfLn} if and only if the functions \texttt{inf\_ln} and \texttt{neg\_inf\_ln} (defined in definition \ref{defn:fn-inf-ln}) can be called on values of type \texttt{T}. 
\end{definition}

\begin{definition}[\texttt{InfSub}]
A type $\T$ has trait \texttt{InfSub} if and only if the function \texttt{inf\_sub} and \texttt{neg\_inf\_sub} (defined in definition \ref{defn:fn-inf-sub}) can be called on values of type \texttt{T}. 
\end{definition}

\subsection{Math-related definitions}
\begin{definition}[\texttt{Add(Output=T)}]
    A type \texttt{T} has trait \texttt{Add(Output=T)} $\iffText$ addition can be performed between elements of type \texttt{T}, with the result of the addition also being of type \texttt{T}.
    
    \inRust{Trait std::ops::Add}{https://doc.rust-lang.org/std/ops/trait.Add.html}
\end{definition}
\begin{definition}[\texttt{Div(Output=T)}]
    A type \texttt{T} has trait \texttt{Div(Output=T)} $\iffText$ division can be performed between elements of type \texttt{T}, with the result of the division also being of type \texttt{T}.
    
    \inRust{Trait std::ops::Div}{https://doc.rust-lang.org/std/ops/trait.Div.html}
\end{definition}
\begin{definition}[\texttt{Mul(Output=T)}]
    A type \texttt{T} has trait \texttt{Mul(Output=T)} $\iffText$ multiplication can be performed between elements of type \texttt{T}, with the result of the multiplication also being of type \texttt{T}.
    
    \inRust{Trait std::ops::Mul}{https://doc.rust-lang.org/std/ops/trait.Mul.html}
\end{definition}
\begin{definition}[\texttt{Sub(Output=T)}]
\label{defn:trait-sub}
    A type \texttt{T} has trait \texttt{Sub(Output=T)} $\iffText$ subtraction can be performed between elements of type \texttt{T}, with the result of the subtraction also being of type \texttt{T}.
    
    \inRust{Trait std::ops::Sub}{https://doc.rust-lang.org/std/ops/trait.Sub.html}
\end{definition}
\begin{definition}[\texttt{Sum(Output=T)}]
    A type \texttt{T} has trait \texttt{Sum(Output=T)} if and only if such type can be created by summing up an iterator. This trait is used to allow the \texttt{sum} function on iterators to be used. Types which implement the trait can be generated by the \texttt{sum()} method.
    
    \inRust{Trait std::iter::Sum}{https://doc.rust-lang.org/std/iter/trait.Sum.html}
\end{definition}
\subsection{Traits that need not appear in the preconditions}
\begin{itemize}
    \item \texttt{'static}. Notes: \texttt{'static} is not a type; it is a lifetime name (this is a Rust definition).
    \item \texttt{Clone}
    \item \texttt{Copy}
\end{itemize}
\horizline
\subsection{Notes, todos, questions}
\section{Functions}
\subsection{Functions in the pseudocode language}
\begin{definition}[\texttt{abs}]
    Given an element \texttt{var} of type \texttt{T}, where \texttt{T} must have trait \texttt{Abs}, the function \texttt{abs} reuturns the absolute value of \texttt{var}.
\end{definition}
\begin{definition}[\texttt{assert}] 
    The function \texttt{assert} is followed by an expression. If \texttt{some\_expression} evaluates to \texttt{False}, then \texttt{assert some\_expression} results in an error that prevents the code from proceeding further. 
    
    \inPython{\texttt{assert}}{https://docs.python.org/3/reference/simple_stmts.html\#the-assert-statement}
\end{definition}
\begin{definition}[\texttt{can\_cast}]
    The function \texttt{can\_cast(type1,type2)} returns $\True$ if and only if no data would be lost by casting from \texttt{type1} to \texttt{type2}. In other words, it returns $\True$ $\iffText$ there is an injection from \texttt{type1} to \texttt{type2}. 
    
    \inRust{std::convert::TryFrom}{https://doc.rust-lang.org/std/convert/trait.TryFrom.html}
\end{definition}
For example, \texttt{can\_cast(u32,u64)} will return $\True$ because a \texttt{u32} can always be expressed as a \texttt{u64}; conversely, \texttt{can\_cast(u64,u32)} will return $\False$ because a \texttt{u64} could be too big to be expressed as a \texttt{u32}, and then data would be lost.
\begin{definition}[\texttt{cast}]
    \texttt{cast(val:TI, TO)} converts \texttt{val} of type \texttt{TI} to the corresponding \texttt{val} of type \texttt{TO}, and returns \texttt{val} of type \texttt{TO}. Returns an error if the conversion is unsuccessful.
\end{definition}
\begin{definition}[\texttt{checked\_add}]
     Given two elements \texttt{var1, var2} of type \texttt{T} with trait \texttt{Add(Output=T)}, \texttt{checked\_add(var1, var2)} returns \texttt{var1+var2} if the result does not overflow/underflow, and else returns \texttt{None}.
\end{definition}
\begin{definition}[\texttt{checked\_mul}]
     Given two elements \texttt{var1, var2} of type \texttt{T} with trait \texttt{Mul(Output=T)}, \texttt{checked\_mul(var1, var2)} returns \texttt{var1*var2} if the result does not overflow/underflow, and else returns \texttt{None}.
\end{definition}
\begin{definition}[\texttt{checked\_sub}]
     Given two elements \texttt{var1, var2} of type \texttt{T} with trait \texttt{Sub(Output=T)}, \texttt{checked\_sub(var1, var2)} returns \texttt{var1-var2} if the result does not overflow/underflow, and else returns \texttt{None}.
\end{definition}
\begin{definition}[\texttt{exact\_int\_cast}]
    This function only works for types \texttt{TO} that have trait \texttt{ExactIntCast(TI)}. For any given \texttt{val} such that \texttt{val} is between \texttt{get\_min\_consecutive\_int(TO)} and \texttt{get\_max\_consecutive\_int(TO)}, then \texttt{exact\_int\_cast(val:TI,TO)} returns an integer value of type \texttt{TO} equal to the integer value held by  \texttt{val} (which was of type \texttt{TI}); otherwise, a cast error is returned.
\end{definition}
\begin{definition}[\texttt{get\_input\_domain}]
    The function \texttt{get\_input\_domain(function)} returns the input domain of arguments passed to function \texttt{function}.
\end{definition}
\begin{definition}[\texttt{get\_input\_metric}]
    The function \texttt{get\_input\_metric(some\_relation)} returns the input metric used by the relation \texttt{some\_relation}.
\end{definition}
\begin{definition}[\texttt{get\_max\_consecutive\_int}]
    This function is only defined on types $\T$ that have trait \texttt{ExactIntCast}. The function \texttt{get\_max\_consecutive\_int(T)} returns the greatest integer $\texttt{i}\geq 0$ such that all integers from 0 up to \texttt{i} (inclusive) can be expressed exactly as a value of type $\T$; but such that $\texttt{i}+1$ cannot be expressed exactly as a value of type $\T$. The return value is of type \texttt{T}.
\end{definition}
\begin{definition}[\texttt{get\_max\_value}]
    This function is only defined on types $\T$ that have a total ordering. The function \texttt{get\_max\_value(T)} returns the maximum value that can be expressed by an object of type \texttt{T}. The return value is of type \texttt{T}.
\end{definition}
\begin{definition}[\texttt{get\_min\_consecutive\_int}]
    This function is only defined on types $\T$ that have trait \texttt{ExactIntCast}. The function \texttt{get\_min\_consecutive\_int(T)} returns the smallest integer $\texttt{i}\leq 0$ such that all integers from 0 down to \texttt{i} (inclusive) can be expressed exactly as a value of type $\T$; but such that $\texttt{i}-1$ cannot be expressed exactly as a value of type $\T$. The return value is of type \texttt{T}.
\end{definition}
\begin{definition}[\texttt{get\_min\_value}]
    This function is only defined on types $\T$ that have a total ordering. The function \texttt{get\_min\_value(T)} returns the minimum value that can be expressed by an object of type \texttt{T}. The return value is of type \texttt{T}.
\end{definition}
\begin{definition}[\texttt{get\_output\_domain}]
    The function \texttt{get\_output\_domain(function)} returns the output domain of values returned by function \texttt{function}.
\end{definition}
\begin{definition}[\texttt{get\_output\_metric}]
    The function \texttt{get\_output\_metric(some\_relation)} returns the output metric used by the relation \texttt{some\_relation}.
\end{definition}
\begin{definition}[\texttt{has\_trait}]
    The function \texttt{has\_trait(T,(trait1,trait2,...))} is a function that returns $\True$ $\iffText$ the type \texttt{T} implements \texttt{trait1}, \texttt{trait2}, etc.
\end{definition}
\begin{definition}[\texttt{inf\_cast}]
\label{defn:inf-cast}
    This function is only defined for casting to types \texttt{TO} that have trait \texttt{InfCast(TI)}. The function \texttt{inf\_cast(val:TI, TO)} casts \texttt{val} to a value of type \texttt{TO} and returns that value. Specifically, \texttt{val} will be casted to the value of type \texttt{TO} that is closest to \texttt{val} and at least as large as \texttt{val}. If \texttt{inf\_cast} is not able to cast \texttt{val} to a value of type \texttt{TO} at least as large as \texttt{val}, then an error is returned instead.
    
    \textbf{Property:} \texttt{inf\_cast}ed distances are never less than input distances.
    
    \emph{Note: the name ``InfCast'' comes from the idea of rounding the result of the cast toward positive \textbf{inf}inity if needed.}
\end{definition}
\begin{definition}[\texttt{is\_instance}]
    The function \texttt{is\_instance(var,T)} returns $\True$ if and only if the variable \texttt{var} is of type \texttt{T}.
\end{definition}
\begin{definition}[\texttt{is\_none}]
    The function \texttt{var.is\_none} returns \texttt{True} if and only if \texttt{var} which is of \texttt{float} is equal to \texttt{None}.
\end{definition}
\begin{definition}[\texttt{is\_null}]
    The function \texttt{var.is\_null} returns \texttt{True} if and only if \texttt{var} which is of type \texttt{Option[T]} is not equal to \texttt{null}.
\end{definition}
\begin{remark}[\texttt{ImputableDomain}]
To check for nullity, we use \texttt{v.is\_null()} if v is a float, or \texttt{v.is\_none()} if v is an \texttt{Option[T]}. To abstract these functions, we define the \texttt{ImputableDomain} trait to capture both notions of nullity.
\end{remark}
\begin{definition}[\texttt{len}]
    The function \texttt{len(vector\_name)} returns the number of elements (with multiplicities) in \texttt{vector} \texttt{vector\_name}. Output is of type \texttt{usize}, so the return value $v$ on 32-bit machines is $v\in \{0,1,2,\ldots,2^{32} - 1\}$; likewise, the return value on 64-bit machines is $v\in \{0,1,2,\ldots,2^{64} - 1\}$. 
    
    \inRust{std::vec::Vec::len}{https://doc.rust-lang.org/std/vec/struct.Vec.html\#method.len}
\end{definition}
\emph{Note: we do not call it \texttt{length} to avoid notational clashes with, for example, the Bounded Sum code.}
\begin{definition}[\texttt{map}]
    A \texttt{map} applies a given function to all the items in an iterable without using an explicit for loop. Hence, \texttt{map(f, iter)} is an iterator that maps the values of \texttt{iter} with \texttt{f}.
    
    \inRust{Struct std::iter::Map}{https://doc.rust-lang.org/std/iter/struct.Map.html}
\end{definition}
\begin{definition}[\texttt{max}]
    The function \texttt{max(var1, var2)} compares \texttt{var1} and \texttt{var2}, and returns the greater of the two values. When \texttt{var1} and \texttt{var2} are equivalent, it returns \texttt{var2}. The return type of \texttt{map} is also an iterator. The function \texttt{max} requires that \texttt{var1} and \texttt{var2} have trait \texttt{TotalOrd}. 
    
    \inRust{std::cmp::max}{https://doc.rust-lang.org/std/cmp/fn.max.html}
\end{definition}
\begin{definition}[\texttt{min}]
    The function \texttt{min(var1:T, var2:T)} compares \texttt{var1} and \texttt{var2}, and returns the lesser of the two values. When \texttt{var1} and \texttt{var2} are equivalent, it returns \texttt{var1}. The function \texttt{min} requires that \texttt{var1} and \texttt{var2} have trait \texttt{TotalOrd}. 
    
    \inRust{std::cmp::min}{https://doc.rust-lang.org/std/cmp/fn.min.html}
\end{definition}
\begin{definition}[\texttt{saturating\_add}]
    \label{defn:fn-saturating-add}
    Given two elements \texttt{var1, var2} of type \texttt{T} with trait \texttt{Add(Output=T)}, the function  \texttt{saturating\_add(var1, var2)} returns \texttt{var1+var2} whenever \texttt{var1+var2} $\in$ \texttt{[get\_min\_value(T), get\_max\_value(T)]}. If \texttt{var1+var2} $<$ \texttt{get\_min\_value(T)}, then \texttt{saturating\_add(var1, var2)} $:=$ \texttt{get\_min\_value(T)}. Similarly, in the case where \texttt{var1+var2} $>$ \texttt{get\_max\_value(T)}, then \texttt{saturating\_add(var1, var2)} $:=$ \texttt{get\_max\_value(T)}. 
    
    \inRust{std::intrinsics::saturating\_add}{https://doc.rust-lang.org/std/intrinsics/fn.saturating_add.html}
\end{definition}
% i.e., this is clamping
\begin{definition}[\texttt{sum}]
    The \texttt{sum} function adds all terms in an iterable incrementally and returns their sum.
    
    This is done by first summing the first two terms and calculating an intermediate result with the same type as the input type (with rounding if applicable). Then the third term is summed with this result and a new intermediate result is calculated. This process continues until the most recent intermediate result is summed with the final term in the iterable, and the result, with the same type as the input type, is returned.
\end{definition}

\begin{definition}[\texttt{inf\_ln} and \texttt{neg\_inf\_ln}]
\label{defn:fn-inf-ln}
The function \texttt{inf\_ln(var:T)} computes the natural logarithm with rounding toward infinity. If \texttt{inf\_ln} results in overflow, an error is returned instead.

The function \texttt{neg\_inf\_ln(var:T)} computes the natural logarithm with rounding toward negative infinity. If \texttt{neg\_inf\_ln} results in overflow, an error is returned instead.
\end{definition}

\begin{definition}[\texttt{inf\_sub} and \texttt{neg\_inf\_sub}]
\label{defn:fn-inf-sub}
Given an element \texttt{var} with trait \texttt{Sub(Output=T)} \questionc{is this true?}, the function \texttt{inf\_sub(var:T)} performs subtraction of \texttt{var} from the element it is called on, with rounding towards infinity. (The element it is called on also must have trait \texttt{Sub(Output=T)}). If this operation cannot be performed without overflowing, an error is returned instead. 

Given an element \texttt{var} with trait \texttt{Sub(Output=T)} \questionc{is this true?}, the function \texttt{neg\_inf\_sub(var:T)} performs subtraction of \texttt{var} from the element it is called on, with rounding towards negative infinity. (The element it is called on also must have trait \texttt{Sub(Output=T)}). If this operation cannot be performed without overflowing, an error is returned instead. 
\end{definition}
\horizline
\subsection{Notes, todos, questions}
\section{Data structures}
\begin{definition}[\texttt{list}]
    A \texttt{list} is a data structure which is a changeable ordered sequence of elements.
\end{definition}
Importantly, we remark that in some occasions in our Python-like pseudocodes we will write \texttt{list} as an equivalent for the Rust \texttt{Vec} in order to maintain a Python-like notation. For this reason, such a \texttt{list} will have type \texttt{Vec(T)} and be considered an element of \texttt{VectorDomain}. We will allow the use of the Rust-like term \texttt{Vec} when type signing the functions in the pseudocode and proving the corresponding domain properties in the proof.
\section{Classes}
\begin{definition}[\texttt{Transformation}]
    We define a \texttt{Transformation} in the following way.
    
    \questionr{Which pseudocode style is preferred for this definition? With preconditions (section \ref{sec:pseudocode-w-preconditions}) or without preconditions (section \ref{sec:pseudocode-wout-preconditions})?}
    
\subsection{Pseudocode with preconditions}
\label{sec:pseudocode-w-preconditions}
\begin{itemize}
    \item \texttt{input\_domain} must have trait \texttt{Domain}
    \item \texttt{output\_domain} must have trait \texttt{Domain}
    \item \texttt{function} must operate on inputs from \texttt{input\_domain}, and it must produce outputs in \texttt{output\_domain}
    \item \texttt{input\_metric} must have trait \texttt{Metric}
    \item \texttt{output\_metric} must have trait \texttt{Metric}
    \item \texttt{stability\_map} must operate on input metrics equal to \texttt{input\_metric}, and it must return the smallest upper bound on distances between output datasets according to \texttt{output\_metric} on neighboring input datasets.
\end{itemize}
\begin{lstlisting}[language=Python]
class Transformation:
    def __init__(self, input_domain, output_domain, function, input_metric, output_metric, stability_map):
        
        self.input_domain = input_domain
        self.output_domain = output_domain
        
        self.function = function
        
        self.input_metric = input_metric
        self.output_metric = output_metric
        
        self.stability_map = stability_map
\end{lstlisting}
    
\subsection{Pseudocode without preconditions}
\label{sec:pseudocode-wout-preconditions}
\begin{lstlisting}[language=Python]
class Transformation:
    def __init__(self, input_domain, output_domain, function, input_metric, output_metric, stability_map):
        
        assert has_trait(input_domain, Domain)
        self.input_domain = input_domain
        assert has_trait(output_domain, Domain)
        self.output_domain = output_domain
        
        assert get_input_domain(function) == input_domain
        assert get_output_domain(function) == output_domain
        self.function = function
        
        assert has_trait(input_metric, Metric)
        self.input_metric = input_metric
        assert has_trait(output_metric, Metric)
        self.output_metric = output_metric
        
        assert get_input_metric(stability_relation) == input_metric
        assert get_output_metric(stability_relation) == output_metric
        self.stability_map = stability_map
\end{lstlisting}
    
    \inOpenDPRust{Transformation}{https://github.com/opendp/opendp/blob/35dbdc73d7d74e049f5101a704d4e036bed365e8/rust/opendp/src/core.rs\#L369-L376} When we refer to a \textit{valid transformation} in the proofs, this is the precise definition.
\end{definition}
Therefore, there is no need to include the following code snippet in all of the pseudocodes:
\begin{lstlisting}[language=Python]
class Transformation:
    input_domain
    output_domain
    function
    input_metric
    output_metric
    stability_map
\end{lstlisting}

\begin{definition}[\texttt{Measurements}]

% \todonei{Add the equivalent pseudocode for Measurements. (Should be very similar; just change names.)}
    We define a \texttt{Measurement} in the following way.
    

    
    \questionr{Which pseudocode style is preferred for this definition? With preconditions (section \ref{sec:pseudocode-w-preconditions}) or without preconditions (section \ref{sec:pseudocode-wout-preconditions})?}
    
\subsection{Pseudocode with preconditions}
\label{sec:pseudocode-w-preconditions}
\begin{itemize}
    \item \texttt{input\_domain} must have trait \texttt{Domain}
    \item \texttt{output\_domain} must have trait \texttt{Domain}
    \item \texttt{function} must operate on inputs from \texttt{input\_domain}, and it must produce outputs in \texttt{output\_domain}
    \item \texttt{input\_metric} must have trait \texttt{Metric}
    \item \texttt{output\_measure} must have trait \texttt{Measure}
    \item \texttt{privacy\_map} must operate on input metrics equal to \texttt{input\_metric}, and it must return the smallest upper bound on distances between output distributions on neighboring input datasets.
    
    % \questionc{not sure about this last one.}
\end{itemize}
\begin{lstlisting}[language=Python]
class Measurement:
    def __init__(self, input_domain, output_domain, function, input_metric, output_measure, privacy_relation):
        
        self.input_domain = input_domain
        self.output_domain = output_domain
        
        self.function = function
        
        self.input_metric = input_metric
        self.output_measure = output_measure
        
        self.privacy_map = privacy_map
\end{lstlisting}
    
\subsection{Pseudocode without preconditions}
\label{sec:pseudocode-wout-preconditions}
\begin{lstlisting}[language=Python]
class Measurement:
    def __init__(self, input_domain, output_domain, function, input_metric, output_measure, privacy_map):
        
        assert has_trait(input_domain, Domain)
        self.input_domain = input_domain
        assert has_trait(output_domain, Domain)
        self.output_domain = output_domain
        
        assert get_input_domain(function) == input_domain
        assert get_output_domain(function) == output_domain
        self.function = function
        
        assert has_trait(input_metric, Metric)
        self.input_metric = input_metric
        assert has_trait(output_measure, Measure)
        self.output_measure = output_measure
        
        assert get_input_metric(privacy_relation) == input_metric
        assert get_output_measure(privacy_relation) == output_measure
        self.privacy_map = privacy_map
\end{lstlisting}
    
\inOpenDPRust{Measurement}{https://github.com/opendp/opendp/blob/35dbdc73d7d74e049f5101a704d4e036bed365e8/rust/opendp/src/core.rs\#L339-L346} When we refer to a \textit{valid measurement} in the proofs, this is the precise definition.
\end{definition}
Therefore, there is no need to include the following code snippet in all of the pseudocodes:
\begin{lstlisting}[language=Python]
class Measurement:
    input_domain
    output_domain
    function
    input_metric
    output_measure
    privacy_map 
\end{lstlisting}
\section{Metrics}
\label{sec:metrics}
\subsection{Dataset metrics}
Metrics are used to measure the distances between data. Metrics have a \emph{domain} on which the function associated with the metric can measure distance, and an \emph{associated type} that determines the type used to represent the distance between datasets.
\textbf{Example:} \texttt{SymmetricDistance} has a domain of \texttt{VectorDomain(AllDomain(T))}, which means that \texttt{SymmetricDistance} can be used to measure the distance between any objects that are vectors of elements of type \texttt{T}. \texttt{SymmetricDistance} has an associated type of \texttt{u32}, which means that a \texttt{u32} value is used to report the distance.
Please refer to the proof definitions document (see section \ref{sec:versioned-docs}) for definitions of the functions referred to by the metrics below.
\note{Once the subdomains have been implemented in OpenDP, it will no longer be necessary to list all of the subdomains in the compatible domains section.}
\begin{definition}[\texttt{AbsoluteDistance(T)}]
\metricDefn{absolute distance}
\begin{itemize}
    \item \textbf{Domain:} \texttt{AllDomain(T)}, where \texttt{T} has the traits \texttt{Sub(Output=T)} (defined in definition \ref{defn:trait-sub}) and \texttt{TotalOrd} (defined in definition \ref{defn:trait-totalord}).
    \item \textbf{Associated type:} \texttt{Q}.
    \item \textbf{$d$-close:} For any two elements $n, m$ in \texttt{AllDomain(T)}, where \texttt{T} denotes an arbitrary type with trait \texttt{Sub(Output=T)}, and $d$ of generic type \texttt{Q}, we say that $n, m$ are $d$-close under the absolute distance metric (abbreviated as $d_{Abs}$) whenever
    \[
        d_{Abs}(n, m) = |n-m| \leq d.
    \]
\end{itemize}
\end{definition}
\begin{definition}[\texttt{SymmetricDistance}]
\metricDefn{symmetric distance} 
\begin{itemize}
    \item \textbf{Domains:} \texttt{VectorDomain(inner\_domain)} and \texttt{SizedDomain(VectorDomain(inner\_domain))}, where \texttt{inner\_domain} is any domain.
    
    \item \textbf{Associated type:} \texttt{IntDistance}.
    \item \textbf{$d$-close:} For any two vectors $u, v \in \texttt{VectorDomain(D)}$ and any $d$ of type \texttt{u32}, we say that $u, v$ are $d$-close under the symmetric distance metric (abbreviated as $d_{Sym}$) whenever 
    \[
        d_{Sym}(u, v) = |\MultiSet(u) \Delta \MultiSet(v)| \leq d.
    \]
\end{itemize}
\end{definition}
\emph{Note: the associated type of \texttt{SymmetricDistance} is hard-coded as \texttt{IntDistance}, so when declaring that the metric being used is \texttt{SymmetricDistance}, we only need to write \texttt{metric = SymmetricDistance()}; by contrast, we need to write \texttt{AbsoluteDistance(T)} where \texttt{T} is the type on which we are taking the absolute distance since the associated type for \texttt{AbsoluteDistance} is not hard-coded.}

\begin{definition}[ChangeOneDistance]
\metricDefn{change-one distance}

\begin{itemize}
    \item \textbf{Domain:} \texttt{AllDomain(T)}
    \item \textbf{Associated type:} \texttt{Q}.
    \item \textbf{$d$-close:} For any two elements $n, m$ in \texttt{AllDomain(T)}, where \texttt{T} denotes an arbitrary type, and $d$ of generic type \texttt{Q}, we say that $n, m$ are $d$-close under the change-one distance metric (abbreviated as $d_{CO}$) whenever
    \[
    d_{CO} = |n - m | \leq d \leq 1
    \]
\end{itemize}



\questionr{Are the domain and associated type correct? Are any further traits needed? Is this definition correct?} 

\end{definition}


\begin{definition}[DiscreteMetric]
\metricDefn{discrete metric}
\begin{itemize}
    \item \textbf{Domain:} \texttt{AllDomain(T)}
    \item \textbf{Associated type:} \texttt{Q}.
    \item \textbf{$d$-close:} For any two elements $u, v$ in \texttt{AllDomain(T)}, where \texttt{T} denotes an arbitrary type, and $d$ of generic type \texttt{u32}, we say that $u, v$ are $d$-close under the discrete metric (abbreviated as $d_{DM}$) when
    \[
    d_{DM} = \text{boolean result of the statement } \{u\neq v\}
    \]
\end{itemize}
\questionr{This discrete metric is slightly different
from other metrics, and I wonder if $d$-closeness is needed, since $d_{DM}$ is either 0 or 1 all the time.
If so, what is a better way to define it?} 
\end{definition}
\subsection{Sensitivity metrics}
\note{Sensitivity metrics are used for measurements (rather than transformations), so our most finalized proofs -- which all deal with transformations -- do not require correctness of the definitions in this section.}
\begin{definition}[\texttt{L1Distance}]
    \metricDefn{L1 distance}
    \item \textbf{Domain:} \texttt{VectorDomain(inner\_domain))}, where \texttt{inner\_domain} is any domain.
    \item \textbf{Associated type:} \texttt{Q}.
    \item \textbf{$d$-close:} For any two vectors $u, v \in \texttt{VectorDomain(D)}$ and $d$ of generic type \texttt{Q}, we say that $u, v$ are $d$-close under the L1 distance metric (abbreviated as $d_{L1}$) whenever
    \[
        d_{L1}(u, v) = \sum_{i=0}^n |u_i - v_i| \leq d.
    \]
\end{definition}
\begin{definition}[\texttt{L2Distance}]
    \begin{definition}[\texttt{L2Distance}]
    \metricDefn{L2 distance}
    \item \textbf{Domain:} \texttt{VectorDomain(inner\_domain))}, where \texttt{inner\_domain} is any domain.
    \item \textbf{Associated type:} \texttt{Q}.
    \item \textbf{$d$-close:} For any two vectors $u, v \in \texttt{VectorDomain(D)}$ and $d$ of generic type \texttt{Q}, we say that $u, v$ are $d$-close under the L2 distance metric (abbreviated as $d_{L2}$) whenever
    \[
        d_{L2}(u, v) = \sqrt{\sum_{i=0}^n |u_i - v_i|^2} \leq d.
    \]
\end{definition}
\end{definition}
\questionr{Are the domain and associated type correct? Are any further traits needed?}
Maybe: include $p$-norms? (See the Wikipedia article at \url{https://en.wikipedia.org/wiki/Norm_(mathematics)\#p-norm} for a definition of $p$-norms.)
\subsection{Measures}
\begin{definition}[\texttt{MaxDivergence}]
    \metricDefn{max divergence} 
    \begin{itemize}
    \item \textbf{Domain:} \texttt{VectorDomain(AllDomain(T))}.
    
    \questionr{Is there any trait required of \texttt{T}? Should it be \texttt{VectorDomain(D)} instead?}
    \item \textbf{Associated type:} \texttt{Q}.
    \item \textbf{$d$-close:} For any two vectors $u, v$ in \texttt{VectorDomain(AllDomain(T))} and any $d$ of generic type \texttt{Q}, we say that $u, v$ are $d$-close under the max divergence measure (abbreviated as $D_{\infty}$) whenever
    \[
        D_{\infty}(u, v) = \max_{S \subseteq \textrm{Supp}(Y)} \Big[\ln \dfrac{\Pr[f(u) \in S]}{\Pr[f(v) \in S]} \Big] \leq d.
    \]
    \questionr{Thoughts on this definition? Should $D_{\infty}$ operate on $u,v$ (so $D_{\infty}(u,v)$), or on $f(u),f(v)$ (so $D_{\infty}(f(u),f(v))$)?}
\end{itemize}
\end{definition}
\horizline
\subsection{Notes, todos, questions}
\todonei{Need to learn how to cross-reference TeX files. After Prof. Vadhan's comment on 19/7, we should think of a systematic way to do dependency tracking.}
\questionr{With regard to the todo above, any recommendations for how to cross-reference between TeX files?}
\section{Code-Definitions update loop}
List of items that have recently changed in the code and have not yet been implemented, or that we know will be implemented soon:
\begin{itemize}
    \item Subdomains for domain-metric compatibility check.
    \item Renaming: \url{https://github.com/opendp/opendp/issues/181}.
\end{itemize}
\end{document}