\documentclass{article}
\input{../mod.sty}


\title{\texttt{mod domains}}
\author{S\'ilvia Casacuberta, Grace Tian, Connor Wagaman}
\date{}

\begin{document}

\maketitle

\contrib

\section{Vetting history}
\begin{itemize}
    \item \vettingPR{491}
\end{itemize}

\section{Definitions}
A \emph{data domain} is a representation of the set of values on which the function associated with a transformation or measurement can operate.  Each metric (see section \ref{sec:metrics}) is associated with certain data domains. Types used for implementing domains in OpenDP have trait \texttt{Domain} (defined in definition \ref{defn:traits-domain}).
\begin{definition}[\texttt{AllDomain}]
\texttt{AllDomain(T)} is the domain of all values of type $\T$. \domainType{AllDomain[T]}
\end{definition}
For example, \texttt{AllDomain(u32)} is the domain of all values of type \texttt{u32}.
\begin{definition}[\texttt{IntervalDomain}] For any type \texttt{T} with trait \texttt{TotalOrd} (see definition \ref{defn:totalord}),\footnote{As of June 28, the OpenDP library requires the weaker condition of partial ordering (implements \texttt{PartialOrd}) instead.} \texttt{IntervalDomain(L:T, U:T)} is the domain of all values \texttt{v} of type \texttt{T} such that \texttt{L <= v} and \texttt{v <= U}, for a type \texttt{T} that has a total ordering (\texttt{T} has trait \texttt{TotalOrd}) and for values \texttt{L <= U} of type \texttt{T}. \domainType{IntervalDomain[T]}
\end{definition}
An important remark is that the Rust implementation of \texttt{IntervalDomain} checks that \texttt{L <= U}, and returns an error if \texttt{L > U}. Therefore, any transformation or measurement that uses \texttt{IntervalDomain} does not need to re-check this constraint and raise a possible exception for it. 
Note that, because both \texttt{L} and \texttt{U} are of type \texttt{T}, there is no need to explicitly pass \texttt{T}; the type \texttt{T} can be inferred. \texttt{IntervalDomain} is defined on any type that implements the trait \texttt{TotalOrd}. For example, \texttt{IntervalDomain(1:u32, 17:u32)} corresponds to a domain that contains all the \texttt{u32} values \texttt{v} such that \texttt{1 <= v} and \texttt{v <= 17}; it has type \texttt{IntervalDomain[u32]}.
\begin{definition}[\texttt{InherentNullDomain}] 
    \texttt{InherentNullDomain(inner\_domain:D)} is the domain of all values of data domain \texttt{inner\_domain} unioned with a \texttt{null} value. Note that this means that a domain may have only \emph{one} \texttt{null} value; as a result, applying \texttt{InherentNullDomain} to a domain already containing a \texttt{null} value will not affect the domain. \domainType{InherentNullDomain[D]}
\end{definition}
\begin{definition}[\texttt{SizedDomain}]
    \texttt{SizedDomain(inner\_domain:D, n:usize)} is the domain of all elements from domain \texttt{D} restricted to length \texttt{n}. \domainType{SizedDomain[D]}
\end{definition}
For example, \texttt{SizedDomain(VectorDomain(AllDomain(u32)), n)} is the domain of all vectors of length $\texttt{n}$ with elements of type \texttt{u32}.
\begin{definition}[\texttt{VectorDomain}]
\texttt{VectorDomain(inner\_domain:D)} is the domain of all vectors of elements drawn from domain \texttt{inner\_domain}. 
\domainType{VectorDomain[D]}
\end{definition}

% TODO: add to issue
% \subsection{Subdomains}
% Preliminary theorems:
% \begin{theorem}[Domain-metric compatibility inheritance.]
%     Given a domain \texttt{D}, for any subdomain \texttt{S} $\subseteq$ \texttt{D}, if \texttt{D} is compatible with metric \texttt{M} then \texttt{S} is compatible with metric \texttt{M}.
% \end{theorem}

\end{document}