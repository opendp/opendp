\documentclass[11pt,a4paper]{article}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{enumerate} 
\usepackage{physics}
\usepackage{enumerate}
\usepackage{fancyhdr}
 \usepackage{hyperref}
\hypersetup{colorlinks,
    linkcolor=blue,
    citecolor=blue,      
    urlcolor=blue,
}
\usepackage{graphicx}
 \usepackage{tcolorbox}


\oddsidemargin0.1cm 
\evensidemargin0.8cm
\textheight22.7cm 
\textwidth15cm \topmargin-0.5cm

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\vicki}[1]{{ {\color{olive}{(vicki)~#1}}}}
\newcommand{\hanwen}[1]{{ {\color{purple}{(hanwen)~#1}}}}
\newcommand{\zach}[1]{{ {\color{red}{(zach)~#1}}}}

\newcommand{\MultiSet}{\mathrm{MultiSet}}
\newcommand{\len}{\mathrm{len}}
\newcommand{\din}{\texttt{d\_in}}
\newcommand{\dout}{\texttt{d\_out}}
\newcommand{\T}{\texttt{T} }
\newcommand{\F}{\texttt{F} }
\newcommand{\Relation}{\texttt{Relation}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\Y}{\mathcal{Y}}
\newcommand{\True}{\texttt{True}}
\newcommand{\False}{\texttt{False}}
\newcommand{\clamp}{\texttt{clamp}}
\newcommand{\function}{\texttt{function}}
\newcommand{\float}{\texttt{float }}
\newcommand{\questionc}[1]{\textcolor{red}{\textbf{Question:} #1}}


\title{Privacy Proofs for OpenDP: Geometric Measurement}
\author{Vicki Xu, Hanwen Zhang, Zachary Ratliff}
\date{Summer 2022}
\begin{document}


\maketitle
\tableofcontents

\section{Algorithm Implementation}
\subsection{Code in Rust}
The current OpenDP library contains the \texttt{make\_base\_geometric} function implementing geometric measurement. This is defined in the adjacent \texttt{mod.rs} file. 

In \texttt{make\_base\_geometric}, which accepts a parameter \texttt{scale} of type \texttt{QO} and a parameter \texttt{bounds} of type \texttt{Option<(D::Atom, D::Atom)>}, the function takes in a data point \texttt{arg} of type \texttt{D::Atom}, \texttt{scale}, and \texttt{bounds}. This function will call \texttt{sample\_two\_sided\_geometric}, which provides a sampling from the two-sided geometric distribution centered at \texttt{arg} with scale parameter \texttt{scale} and saturated at the bounds denoted by \texttt{bounds}. If \texttt{bounds} is not provided, then the two-sided geometric sample saturates at the bounds of the data type, \texttt{MAX} and \texttt{MIN}. The function returns the sampled element given the parameters. 

\subsection{Pseudo Code in Python}\label{sec:pseudocode}

We present a simplified Python-like pseudocode of the Rust implementation below. The necessary definitions for the non-sampler pseudocode can be found at \href{https://github.com/opendp/whitepapers/blob/pseudocode-defns/pseudocode-defns/pseudocode_defns.pdf}{``List of definitions used in the pseudocode"}. \vicki{fix link} For samplers (such as \texttt{sample\_bernoulli}), the definitions will be found at \vicki{insert link here}

\subsubsection*{Preconditions}
To ensure the correctness of the output, we require the following preconditions:

\begin{itemize}
    \item \textbf{User-specified types:}
    \begin{itemize}
        \item Variable \texttt{scale} must be of type \texttt{QO}
        \item Variable \texttt{bounds} must be of type \texttt{Option(D::Atom, D::Atom)}
        \item Type \texttt{D} must have trait \texttt{GeometricDomain}
        \item Type \texttt{D::Atom} must have trait \texttt{Integer}
        \item Type \texttt{QO} must have traits \texttt{Float} and \texttt{InfCast<D::Atom>}
    \end{itemize}
\end{itemize}

\subsubsection*{Postconditions}

\begin{itemize}
    \item A \texttt{Measurement} is returned (i.e., if a \texttt{Measurement} cannot be returned successfully, then an error should be returned).
\end{itemize}


\begin{lstlisting}[language=Python,  escapechar=|]
# implement noise function for scalar input 
def noise_function<AllDomain<T>>(scale : QO, bounds? : {T, T}):
    def function(arg : D::Atom, scale : QO, bounds?: {D::Atom, D::Atom}) -> <D, QO>: |\label{line:fn}|
        return sample_two_sided_geometric(arg, scale, bounds)
        
    return function

# implement noise function for vector input  
def noise_function<VectorDomain<AllDomain<T>>(scale : QO, bounds? : {T, T}):
    def function(arg : Vector<D::Atom>, scale : QO, bounds?: {D::Atom, D::Atom}) -> <D, QO>: |\label{line:fn}|
        noised = new Vector<AllDomain<T>>
        for (item in arg):
           noised.add(sample_two_sided_geometric(item, scale, bounds))
          
        return noised
           
    return function

# parameterize by domain D
def make_base_geometric<D>(scale: QO, bounds={"lower": D::Atom::MIN, "upper": D::Atom::MAX}):
    input_domain = D
    output_domain = D
    # ---------------------------------
    # To reduce redundancy, we don't copy and paste the whole function.
    # The idea is to have different input metrics for two input settings.
    
    # check for scalar or vector input
    if isinstance(D, AllDomain<T>):
        input_metric = AbsoluteDistance<D::Atom> 
    elif isinstance(D, VectorDomain<AllDomain<T>>):
        input_metric = L1Distance<D::Atom>
    # ---------------------------------
    
    similarity_metric = MaxDivergence<QO>
    function = input_domain.noise_function(scale, bounds)
    
    # check scale sign
    if (scale < 0): |\label{line:scale}|
        raise Exception("scale must not be negative")
        
    # check bounds - can discuss if python dict is best representation of this
    if (bounds["lower"] > bounds["upper"]): |\label{line:bounds}|
        raise Exception("lower may not be greater than upper")

    def privacy_map(d_in: D::Atom) -> QO: |\label{line:map}|
        if (d_in < 0): |\label{line:positivedin}|
            raise Exception("sensitivity must be non-negative")
        if (scale == 0):
            return QO::MAX
        return inf_div(d_in, scale)
    
    return Measurement(input_domain, output_domain, function, input_metric, similarity_metric, privacy_map)

\end{lstlisting}

\vicki{marked bounds with [SELF::MIN, SELF::MAX] because it's an optional type in the original Rust code, and if not specified, then in SampleTwoSidedGeometric SELF::MIN and SELF::MAX are substituted}



\subsection{Proof}

\begin{theorem}
For every setting of the input parameters \texttt{constant} to \texttt{make\_base\_geometric} such that the given preconditions hold, the transformation returned by \texttt{make\_base\_geometric} satisfies the following statements:

\begin{enumerate}
    \item \textup{(Domain-metric compatibility.)} The domain \texttt{input\_domain} matches one of the possible domains listed in the definition of \texttt{input\_metric}. 
    \item \textup{(Privacy guarantee.)} Let \texttt{d\_in} have the associated type for \texttt{input\_metric}, and let $D$ have associated type for \texttt{similarity\_metric}. For every pair of elements $v, w$ in \texttt{input\_domain} and every \texttt{d\_in}, if $v, w$ are \texttt{d\_in}-close under \texttt{input\_metric}, then \texttt{function}(v), \texttt{function}(w) are \texttt{map(d\_in)}-close with respect to $D$.
\end{enumerate}
\end{theorem}
\begin{proof}
\begin{enumerate}
    \item \textbf{(Domain-metric compatibility.)} For \texttt{make\_base\_geometric}, this corresponds to showing \texttt{AllDomain(T)} is compatible with \texttt{AbsoluteDivergence}. This follows directly from the definition of \texttt{AbsoluteDivergence}, as stated in the \href{https://github.com/opendp/whitepapers/blob/pseudocode-defns/pseudocode-defns/pseudocode_defns.pdf}{``List of definitions used in the pseudocode"}.
    \item \textbf{(Privacy guarantee.)} 
    % This proof assumes the correctness of \texttt{sample\_two\_sided\_geometric}, asserted by the following lemma. 
    % \begin{tcolorbox}
    % \begin{lemma}
    % \texttt{sample\_two\_sided\_geometric(shift, scale, bounds)} is a function that samples with no privacy violation from a two-sided geometric distribution centered at \texttt{shift}, with scale parameter \texttt{scale}, and saturated at the bounds denoted by \texttt{bounds}.
    % In other words, this function properly 
    % simulates a random variable $Z \sim $ 
    % \texttt{shift} $+ 
    % \text{ Geo}$(\texttt{scale}), with
    % probability mass function
    % $f_Z(z)\propto \exp{-|z-\texttt{shift}|/\texttt{scale}}$,
    % and clamps the result at the specified 
    % \texttt{bounds}, if given.
    % \end{lemma} \vicki{not sure if this is right}
    % \hanwen{added a few according to the formal def, but still needs review/suggestion}
    % \end{tcolorbox}
    The following proof is built up on Theorem 2.1 in the proof
    of \texttt{sample\_two\_sided\_geometric(shift, scale, bounds)}, which is the following: \hanwen{link to be put here}
    
    \begin{tcolorbox}
    \begin{theorem}
     For every setting of input parameters \texttt{shift, scale, bounds} such that the preconditions hold, \texttt{sample\_two\_sided\_geometric} returns a draw from the censored two-sided geometric distribution with scale parameter \texttt{scale}, centered at \texttt{shift}, and saturated at the bounds denoted by \texttt{bounds}. 
    \end{theorem}

    \end{tcolorbox}
    % \textbf{TODO}
    Before we begin our proof, we note that the measurement is parameterized by a domain \texttt{D} of type \texttt{AllDomain<T>} or \texttt{VectorDomain<AllDomain<T>>}.
    
    Let $v,w$ be two datasets that are \texttt{d\_in}-close with respect to \texttt{input\_metric}, which is defined to be
    \texttt{L1Distance} with the vector case (\texttt{D = VectorDomain<AllDomain<T>>}) or \texttt{AbsoluteDistance} with the scalar case (\texttt{D = AllDomain<T>}). We only prove the case for when \texttt{D = VectorDomain<AllDomain<T>>} since the scalar case trivially follows.  
    
    According to its definition 
    in the proof definition document, \texttt{d\_in}$=d_{L1}(v,w)=\sum ^n_{i=1}|v_i-w_i|$,
    where $n$ is the dimension of $v,w$.
    Here it is implicitly assumed that $|v|=|w|$.
    
    Let $s=$\texttt{ scale}, $[a,b]=$\texttt{ bounds},
    $Y=\function(v)$, and $Z=\function(w)$.
    Our goal is to show that \texttt{MaxDivergence}  $D_{\infty}(Y||Z)$, also defined in the proof definition document, adheres to the privacy guarantee.
    
    Observe that by the definition of \texttt{noise\_function} implemented for \texttt{VectorDomain<AllDomain<T>>}, and by Theorem 1.2, it follows that \texttt{function}() returns a random variable $Z \sim $ 
    \texttt{shift} $+ 
    \text{ Geo}$(\texttt{scale}), with
    probability mass function
    $f_Z(z)\propto \exp{-|z-\texttt{shift}|/\texttt{scale}}$ along each axis of the input vector. So it follows that 
     \[
    D_{\infty}(Y||Z) = \max_{S \subseteq Supp(Y)}\left[\ln (\frac{\Pr[Y \in S]}{\Pr[Z \in S]})\right] 
    \]
    
    \[
    = \max_{y\in Supp(Y)}\left[\ln (\frac{\Pr[
    \function(v) = y]}
    {\Pr[\function(w) = y]})\right]
    \]
    
    \[
    = \max_{y\in Supp(Y)}\sum^n_{i=1}\left[\ln (\frac{\exp{-|y_i-v_i|/s}}
    {\exp{-|y_i-w_i|/s}})\right]
    \]
    
    \[
    = \max_{y\in Supp(Y)}\sum^n_{i=1}\left[\ln (\exp{(|y_i-w_i|-|y_i-v_i|)/s})\right]
    \]
    
    \[= \max_{y\in Supp(Y)}\frac{1}{s} \sum^n_{i=1}
    |y_i-w_i|-|y_i-v_i|\]
    
    % \[\leq \max_{y,y'\in Supp(Y)}\sum^n_{i=1}\Big|
    % |y_i-v_i|-|y_i-w_i|\Big|/s\]
    
    \[
    \leq \frac{1}{s} \sum^n_{i=1}|w_i-v_i| \hspace{5px} \textrm{  by the Triangle inequality}
    \]
    
    \[
    =\frac{1}{s}\sum^n_{i=1}|w_i-v_i|
    =\texttt{d\_in}/\texttt{scale} \hspace{5px} 
    \]
    
%Because \function() has a discrete output domain we are able to switch from set to point-wise comparison as shown in the first and second lines. 

%The summation in the third line comes from the vector input, where dimension $n$ represents the size of the input. The exponential function inside the summation is given by the fact of the probability mass function of the geometric distribution. 
%After basic algebraic manipulation, we apply the triangle inequality and obtain the last line. The result can be written 
%as \texttt{d\_in}/\texttt{scale}, as desired.\\
%This completes the proof of privacy guarantee.
 
 \textbf{Failure cases.} We still need to account for failure cases within the \texttt{privacy\_map} code. There is one place the code raises an exception:
 
 \begin{enumerate}
     \item \texttt{inf\_div} fails. This step is only reached if \texttt{d\_in} is nonnegative. As defined in the pseudocode definitions doc, \texttt{inf\_div} throws an exception if division overflows from a 32-bit integer. 
 \end{enumerate}
 
Otherwise, \texttt{privacy\_map} returns \texttt{inf\_div(d\_in, scale)}.
\end{enumerate}
\end{proof}
% \hanwen{In the original proof def doc, for L1Dist and other related ones, the sum goes from $i=0$ instead of 
% $i=1$, but I don't think it makes sense to have $0$-dim 
% vectors? The dim would start with 1, at least...}

% \hanwen{question for reviewer: not sure if it's correct to go from the first line to the second like this, i.e., go from set to point}

% \noindent\textbf{Remark.}
% The term \textit{linear} refers to the linear time in which the sampler returns a draw, and this does not affect
% the proof of privacy guarantee in this document as
% long as the features of geometric distribution holds.
% \hanwen{might need different wording etc}

% the section above is removed because we don't need to mention linear in our measurement proof. (we need it in the sampler proof!)
\end{document}

