\documentclass{article}
\input{../../mod.sty}

\title{\texttt{fn make\_clamp}}
\author{S\'ilvia Casacuberta}
\date{}

\begin{document}

\maketitle

\contrib
Proves soundness of \texttt{fn make\_clamp} in \asOfCommit{mod.rs}{0db9c6036}.

% Check the macro when commit hash is up-to-date:
% \asOfCommit{mod.rs}{5223a69c9}

\section{Vetting history}
\begin{itemize}
    \item \vettingPR{512}
\end{itemize}

\section{Versions of definitions documents}
\label{sec:versioned-docs}

When looking for definitions for terms that appear in this document, the following versions of the definitions documents should be used.

\begin{itemize}
    \item \textbf{Pseudocode definitions document:} This proof file uses the version of the pseudocode definitions document available as of September 6, 2021, which can be found at \href{https://github.com/opendp/whitepapers/blob/f8b279ab249934182f306138fa14e6390ddae3e9/pseudocode-defns/pseudocode_defns.pdf}{this link} (archived \href{https://web.archive.org/web/20210906201546/https://raw.githubusercontent.com/opendp/whitepapers/pseudocode-defns/pseudocode-defns/pseudocode_defns.pdf}{here}).
    
    \item \textbf{Proof definitions document:} This file uses the version of the proof definitions document available as of September 6, 2021, which can be found at \href{https://github.com/opendp/whitepapers/blob/d4c24e55cc37878634fec0b7f5c89259a3ad3ded/proof-defns/proof_defns.pdf}{this link} (archived \href{https://web.archive.org/web/20210906201056/https://raw.githubusercontent.com/opendp/whitepapers/proof-defns/proof-defns/proof_defns.pdf}{here}). 
\end{itemize}

\section{Algorithm implementation}

\subsection{Pseudocode in Python}\label{sec:pseudocode}
We present a simplified Python-like pseudocode of the Rust implementation below. The necessary definitions for the pseudocode can be found at \href{https://www.overleaf.com/project/60d215bf90b337ac02200a99}{``List of definitions used in the pseudocode"}. 

\emph{The use of \texttt{code}-style parameters in the preconditions section below (for example, \texttt{input\_domain}) means that this information should be passed along to the \texttt{Transformation} constructor.}

\subsubsection*{Preconditions}
To ensure the correctness of the output, we require the following preconditions:

\begin{itemize}
    \item \textbf{User-specified types:}
    \begin{itemize}
        \item Type \texttt{T} must have trait \texttt{TotalOrd}.
    \end{itemize}
\end{itemize}


\begin{lstlisting}[language=Python, escapechar=|] 
def make_clamp((L, U): (T, T)): |\label{line:def}|
    input_domain = VectorDomain(AllDomain(T))
    output_domain = VectorDomain(IntervalDomain(L, U)) |\label{line:output}|
    input_metric = SymmetricDistance()
    output_metric = SymmetricDistance()
    
    def stability_map(d_in: u32) -> bool: |\label{line:map}|
        return d_in
    
    def function(data: Vec[T]) -> Vec[T]: |\label{line:fn}|
        def clamp(x: T) -> T: |\label{line:clamp}|
            return x.total_clamp(L, U)
        return list(map(clamp, data)) |\label{line:fn-map}|
    
    return Transformation(
        input_domain, output_domain, function, 
        input_metric, output_metric, stability_relation
    )
\end{lstlisting}

\subsubsection*{Postconditions}
\begin{itemize}
    \item Either a valid \texttt{Transformation} is returned or an error is returned.
\end{itemize}

\section{Proof}
The necessary definitions for the proof can be found at \href{https://www.overleaf.com/project/60d214e390b337703d200982}{``List of definitions used in the proofs"}.

\subsection{Symmetric distance}
\transformationTheorem{\texttt{(L, U)}}{\texttt{make\_clamp}}

\begin{proof}
\textbf{(Appropriate output domain).} In the case of \texttt{make\_clamp}, this corresponds to showing that for every vector $v$ of elements of type \texttt{T}, $\function(v)$ is a vector of elements of type \texttt{T} which are contained in the interval \texttt{[L, U]}. For that, we need to show two things: first, that \texttt{function(v)} has type \texttt{Vec[T]}.
Second, that they belong to the interval \texttt{[L, U]}.

Firstly, that $\function(v)$ has type \texttt{Vec[T]} follows from the assumption that element $v$ is in \texttt{input\_domain} and from the type signature of \texttt{function} in line~\ref{line:fn} of the pseudocode (Section~\ref{sec:pseudocode}), which takes in an element of type \texttt{Vec[T]} and returns an element of type \texttt{Vec[T]}. If the Rust code compiles correctly, then the type correctness follows from the definition of the type signature enforced by Rust. Otherwise, the code raises an exception for incorrect input type. 

Secondly, we need to show that the vector entries belong to the interval \texttt{[L, U]}. For that, it is foremost necessary that \texttt{L} $\leq$ \texttt{U}. This condition is already checked when declaring \texttt{output\_domain = VectorDomain(IntervalDomain(L, U))} in line~\ref{line:output} of the pseudocode. This check already exists via the construction of \texttt{IntervalDomain}, which returns an error if \texttt{L} $>$ \texttt{U}. The rest follows from the definition of \texttt{clamp} in line \ref{line:clamp}. According to line \ref{line:clamp} in the pseudocode, there are 3 possible cases to consider:
\begin{enumerate}
    \item \texttt{x} $>$ \texttt{U}: then $\clamp\texttt{(x)}$ returns \texttt{U}.
    \item \texttt{x} $\in$ \texttt{[L, U]}: then $\clamp\texttt{(x)}$ returns \texttt{x}.
    \item \texttt{x} $<$ \texttt{L}: then $\clamp\texttt{(x)}$ returns \texttt{L}.
\end{enumerate}
In all three cases, the returned value of type \T is contained in the interval \texttt{[L, U]}. Hence, the vector $\function(v)$ returned in line~\ref{line:fn-map} of the pseudocode is an element of \texttt{output\_domain}.

Lastly, both \texttt{L} and \texttt{U} have type \texttt{T} by the type signature of \texttt{make\_clamp}. Both the definition of \texttt{IntervalDomain} and that of the \texttt{clamp} function (line~\ref{line:clamp} in the pseudocode, which uses the \texttt{min} and \texttt{max} functions) require that \texttt{T} implements \texttt{TotalOrd}, which holds by the preconditions.

\smallskip
\textbf{(Domain-metric compatibility).} For \texttt{make\_clamp}, both the input and output cases correspond to showing that \texttt{VectorDomain(T)} is compatible with the symmetric distance metric. This follows directly from the definition of symmetric distance, as stated in \href{https://www.overleaf.com/project/60d215bf90b337ac02200a99}{``List of definitions used in the pseudocode"}.

\smallskip
\textbf{(Stability guarantee).} Throughout the stability guarantee proof, we can assume that $\function(v)$ and $\function(w)$ are in the correct output domain, by the \textit{appropriate output domain property} shown above. 

Since by assumption $\Map(\din) \leq \dout$, by the \texttt{make\_clamp} stability map (as defined in line~\ref{line:map} in the pseudocode), we have that $\din \leq \dout$. 
Moreover, $v, w$ are assumed to be $\din$-close. By the definition of the symmetric difference metric, this is equivalent to stating that $d_{Sym}(v, w) = |\MultiSet(v) \Delta \MultiSet(w)| \leq \din$.

Let $\mathcal{X}$ be the domain of all elements of type \texttt{T}. By applying the histogram notation,\footnote{Note that there is a bijection between multisets and histograms, which is why the proof can be carried out with either notion. For further details, please consult \url{https://www.overleaf.com/project/60d214e390b337703d200982}.}  it follows that
\[
d_{Sym}(v, w) = \lVert h_{v} - h_{w}\rVert_1 = \sum_{z \in \mathcal{X}} |h_v(z) - h_w(z)| \leq \din \leq \dout.
\]

By Definition 3.10 in \href{https://www.overleaf.com/project/60d214e390b337703d200982}{``List of definitions used in the proofs"} and the definition of \texttt{clamp} in lines \ref{line:clamp}--\ref{line:fn-map} in the pseudocode, it follows that the \texttt{function} defined in \texttt{make\_clamp}, which maps elements from \texttt{VectorDomain} to \texttt{VectorDomain}, is a row transform. Therefore, by Lemma 3.13 in \href{https://www.overleaf.com/project/60d214e390b337703d200982}{``List of definitions used in the proofs"}, it follows that for every pair of elements $v, w$ in \texttt{input\_domain},
\[
    d_{Sym}(\texttt{function}(v), \texttt{function}(w)) \leq d_{Sym}(v, w).
\]
Then, by the initial assumptions \texttt{relation(\din, \dout) = True} and $\din \leq \dout$, it follows that
\[
    d_{Sym}(\texttt{function}(v), \texttt{function}(w)) \leq d_{Sym}(v, w) \leq \din \leq \dout.
\]
Hence,
\[
    d_{Sym}(\texttt{function}(v), \texttt{function}(w)) \leq \dout,
\]
as we wanted to show.
\end{proof}

\end{document}
