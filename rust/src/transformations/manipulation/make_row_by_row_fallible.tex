\documentclass{article}
\input{../../lib.sty}

\title{\texttt{fn make\_row\_by\_row\_fallible}}
\author{Michael Shoemate}
\date{}

\begin{document}

\maketitle

\contrib
Proves soundness of \rustdoc{transformations/fn}{make\_row\_by\_row\_fallible} in \asOfCommit{mod.rs}{f5bb719}.

\texttt{make\_row\_by\_row\_fallible} returns a Transformation that applies a user-specified function to each record in the input dataset.

\subsection*{Vetting History}
\begin{itemize}
    \item \vettingPR{562}
\end{itemize}

\section{Hoare Triple}
\subsection*{Precondition}
\begin{itemize}

    \item \texttt{DI} (input domain) is a type with trait \rustdoc{transformations/manipulation/trait}{RowByRowDomain}\texttt{<DO>}. 
        This trait provides a way to apply a map function to each record in the input dataset to retrieve a dataset that is a member of the output domain, of type \texttt{DO}. The trait further implies that \texttt{DatasetDomain} is also implemented for \texttt{DI}.
    \item \texttt{DO} (output domain) is a type with trait \rustdoc{transformations/manipulation/trait}{DatasetDomain}. 
        \texttt{DatasetDomain} is used to define the type of the row domain.
    \item \texttt{M} (metric) is a type with trait \rustdoc{transformations/manipulation/trait}{DatasetMetric}. 
        \texttt{DatasetMetric} is used to restrict set of valid metrics to those which measure distances between datasets.
    \item \rustdoc{core/trait}{MetricSpace} is implemented for \texttt{(DI, M)}. Therefore \texttt{M} is a valid metric on \texttt{DI}.
    \item \rustdoc{core/trait}{MetricSpace} is implemented for \texttt{(DO, M)}.
    \item If the input to \texttt{row\_function} is a member of \texttt{input\_domain}'s row domain, then the output is a member of \texttt{output\_domain}'s row domain.
\end{itemize}

\subsection*{Pseudocode}
\begin{lstlisting}[language = Python, escapechar=|]
def make_row_by_row(
    input_domain: DI, 
    input_metric: M, 
    output_row_domain: DO, 
    # a function from input domain's row type to output domain's row type
    row_function: Callable([[DI::RowDomain::Carrier], DO::RowDomain::Carrier])
) -> Transformation:
    
    # where .translate is defined by the RowByRowDomain trait
    output_domain = input_domain.translate(output_row_function)

    def function(data: DI::Carrier) -> DO::Carrier:
        # where .apply_rows is defined by the RowByRowDomain trait
        return DI.apply_rows(data, row_function)

    stability_map = new_stability_map_from_constant(1)

    return Transformation(
        input_domain, output_domain, function,
        input_metric, input_metric, stability_map)
\end{lstlisting}

\subsection*{Postcondition}
\validTransformation{\texttt{(input\_domain, input\_metric, output\_domain, row\_function, DI, DO, M)}}{\texttt{make\_row\_by\_row}}

\section{Proofs}

\begin{proof} \textbf{(Part 1 -- appropriate output domain).}
    By the definition of \texttt{RowByRowDomain}, \texttt{DI.apply\_rows(data, row\_function)} returns a dataset in \texttt{input\_domain.translate(output\_row\_domain)},
    if \texttt{row\_function} is a mapping between \texttt{input\_domain}'s row domain to \texttt{output\_row\_domain}.
    This is satisfied by the precondition on \texttt{row\_function}.
    Thus, for all settings of input arguments, the function returns a dataset in the output domain.
\end{proof}

\begin{proof} \textbf{(Part 2 -- stability map).} 
    Take any two elements $u, v$ in the \\\texttt{input\_domain} and any pair $(\din, \dout)$, 
    where \din\ has the associated type for \texttt{input\_metric} and \dout\ has the associated type for \texttt{output\_metric}.
    Assume $u, v$ are \din-close under \texttt{input\_metric} and that $\texttt{stability\_map}(\din) \leq \dout$. 
    These assumptions are used to establish the following inequality:
    \begin{align*}
        |\function(u) - \function(v)| &\leq \\
        &\leq \dout
    \end{align*}

    It is shown that \function(u), \function(v) are \dout-close under \texttt{output\_metric}.
\end{proof}

\end{document}
