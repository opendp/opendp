\documentclass{article}
\input{../../../../lib.sty}

\title{\texttt{impl InverseCDF for ExponentialEV}}
\author{Michael Shoemate}
\begin{document}

\maketitle

\contrib

Proves soundness of the implementation of \rustdoc{traits/samplers/psrn/trait}{InverseCDF} 
for \rustdoc{traits/samplers/psrn/exponential/struct}{ExponentialRV}.

The implementation computes the inverse CDF of an exponential random variable.

\section{Hoare Triple}

\subsection*{Preconditions}
\subsubsection*{Compiler-verified}
\begin{itemize}
    \item Argument \texttt{self} of type \rustdoc{traits/samplers/psrn/exponential/struct}{ExponentialRV}.
    \item Argument \texttt{r\_unif} of type \texttt{RBig}.
    \item Argument \texttt{refinements} of type \texttt{usize}.
    \item Generic \texttt{R} implements \rustdoc{traits/samplers/psrn/trait}{ODPRound} which denotes the rounding mode, either up or down.
\end{itemize}

\subsubsection*{Caller-verified}
Argument \texttt{r\_unif} is in $[0, 1]$.

\subsection*{Pseudocode}

\lstinputlisting[language=Python,firstline=2,escapechar=`]{./pseudocode/InverseCDF_for_ExponentialRV.py}

\subsection*{Postcondition}

\begin{theorem}
Given a random variable \texttt{self} (of type \rustdoc{traits/samplers/psrn/exponential/struct}{ExponentialRV}),
the algorithm returns \texttt{Some(out)} where \texttt{out} is the inverse cumulative distribution function of \texttt{ExponentialRV} (which includes a rescale and shift) evaluated at \texttt{r\_unif}
with error in direction \texttt{R}, or \texttt{None}.

The error between \texttt{out} and the exactly-computed CDF decreases monotonically as \texttt{refinements} increases.
\end{theorem}

\begin{proof} 

By the definition of \rustdoc{traits/samplers/psrn/exponential/struct}{ExponentialRV},
the density function of the exponential random variable is given by

\begin{equation*}
    f(x) =
    \begin{cases}
        \frac{1}{\lambda} e^{-\frac{x - \mu}{\lambda}} & \text{if } x > \mu \\
        0 & \text{otherwise}
    \end{cases}
\end{equation*}

where $\mu$ denotes \texttt{self.shift},
and $\lambda$ denotes \texttt{self.scale}.

The cumulative distribution function (CDF) is given by
\begin{equation*}
    F(x) = 
    \begin{cases}
        0 & \text{if } x \leq \mu \\
        1 - e^{-\frac{x - \mu}{\lambda}} & \text{if } x > \mu
    \end{cases}
\end{equation*}

The inverse CDF is given by
\begin{equation*}
    F^{-1}(p) = 
    \begin{cases}
        \mu & \text{if } p = 0 \\
        -\lambda \ln(1 - p) + \mu & \text{if } 0 < p < 1
    \end{cases}
\end{equation*}

Let $p$ denote \texttt{r\_unif}.

We now compute the inverse CDF of the exponential random variable
under the requirements that all computations result in a final output in the direction of \texttt{R}.
The code directly matches the inverse CDF, but we need to be careful about the rounding directions.

Starting from the end of the algorithm, and working backwards, we see that, after the negation on line \ref{ln},
the rounding direction of the output is \texttt{R}, consistent with the postcondition.
Then, all calculations until the complement on line \ref{line:complement} are conducted with complementary rounding,
consistent with the postcondition.
The complement on line \ref{line:complement} is then computed with exact rational arithmetic.

Finally, in the case that \texttt{r\_unif} is exactly one, or close enough for conservative arithmetic to underflow,
line \ref{line:infinity} returns \texttt{None}, which is consistent with the postcondition.

The implementation computes the inverse CDF and in the output, rounding always tends towards \texttt{R}, 
and error decreases monotonically as \texttt{refinements} increases,
therefore the postcondition is satisfied.
\end{proof}

\end{document}
