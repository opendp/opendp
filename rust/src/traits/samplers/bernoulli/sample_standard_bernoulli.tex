\documentclass{article} % necessary for Overleaf to recognize the file
\input{../lib.sty} % "rust/src/lib.sty" contains boilerplate and macros

\title{\texttt{fn sample\_standard\_bernoulli}}
\author{Pranav S Ramanujam}\date{18/01/2026}

\begin{document}
\maketitle\contrib
Proves soundness of \rustdoc{traits/samplers/bernoulli/fn}{sample\_standard\_bernoulli}
in \asOfCommit{rust/src/traits/samplers/bernoulli/mod.rs}{655696c}.

\section{Hoare Triple}

\subsection*{Preconditions}
\noindent
There are no preconditions for \texttt{sample\_standard\_bernoulli}.

\subsection*{Pseudocode}
\begin{lstlisting}[language = Python, escapechar=|]
def sample_standard_bernoulli():
    buffer = sample_uniform_byte()
    return (buffer & 1) == 1   |\label{line:out}|
\end{lstlisting}

\subsection*{Postcondition}
For any setting of the input parameters for which the preconditions hold,
\texttt{sample\_standard\_bernoulli} either:
\begin{itemize}
    \item returns \texttt{Err(e)} if there is insufficient system entropy, or
    \item returns \texttt{Ok(sample)} where \texttt{sample} is a draw from
    $\texttt{Bernoulli}(0.5)$.
\end{itemize}

\section{Proof}

We first consider the behavior of the function
\rustdoc{traits/samplers/uniform/fn}{fill\_bytes}, which is invoked inside
\texttt{fn sample_standard_bernoulli}. 
The precondition of \rustdoc{traits/samplers/uniform/fn}{fill_bytes}
is trivially satisfied. Hence, we may assume its postcondition, which states:

\begin{enumerate}
    \item If sufficient system entropy is available, 
    \texttt{fill_bytes} succeeds and fills the single-byte buffer
    \texttt{buffer} with a uniformly random value in the set
    $\{0,1,\dots,255\}$.

    \item If insufficient system entropy is available,
    \texttt{fill_bytes} fails and returns \texttt{Err(e)}.
\end{enumerate}

We now analyze the behavior of
\texttt{fn sample_standard_bernoulli} under these two cases.

\paragraph{Case 1: \texttt{fill_bytes} succeeds.}

In this case, \texttt{buffer[0]} is uniformly distributed over
$\{0,1,\dots,255\}$. The function evaluates the expression

\[
\texttt{buffer[0] \& 1 == 1}.
\]

The bitwise AND operation \texttt{\& 1} extracts the least significant bit
of \texttt{buffer[0]}. Therefore, the function returns \texttt{true} if and
only if the least significant bit of \texttt{buffer[0]} equals $1$.

Among the integers $\{0,1,\dots,255\}$, exactly half (128 values) are even
and half are odd. Even integers have least significant bit equal to $0$,
and odd integers have least significant bit equal to $1$. Since
\texttt{buffer[0]} is uniformly distributed over this set, we obtain

\[
\Pr[\texttt{buffer[0] \& 1 == 1}] = \frac{128}{256} = \frac{1}{2}.
\]

Hence, conditioned on success of \texttt{fill_bytes},
\texttt{sample_standard_bernoulli} returns:
\[
\Pr[\texttt{Ok(true)}] = \frac{1}{2},
\qquad
\Pr[\texttt{Ok(false)}] = \frac{1}{2}.
\]

Thus, the output distribution is exactly
$\texttt{Bernoulli}(0.5)$.

\paragraph{Case 2: \texttt{fill_bytes} fails.}

If \texttt{fill_bytes} returns \texttt{Err(e)}, then
\texttt{sample_standard_bernoulli} immediately propagates the error via the
\texttt{?} operator and returns \texttt{Err(e)}.

Therefore, in all cases,
\texttt{sample\_standard\_bernoulli} either returns \texttt{Err(e)} if there is
insufficient system entropy, or returns a sample drawn from
$\texttt{Bernoulli}(0.5)$, as required by the postcondition. Thus, the postcondition is satisfied.

\end{document}
